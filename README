1. Program zaczyna się od wczytania biblioteki i deklaracji zmiennych używanych w programie.

#include <iostream>

using namespace std;

int opcja; // do wyboru czy sie konczy czy przechodzi do nastepnego wpisanie

int x; // wiersze

int y; // kolumny

int macierz[100][100]; // deklaracja macierzy na ktorej sie operuje

int macierzpomocnicza[100][100]; // deklaracja macierzy pomocniczej do zapisywania obliczen

int Rozmiar_x; // ilosc wierszy w macierzy

int Rozmiar_y; // ilosc kolumn w macierzy

int numer_generacji; // liczba generacji od rozpoczecia symulacji

int komurki_sasiadujace; // zliczenie ile komórka ma sąsiadów żywych

int przeskok; // o ile pokoleń ma przeskoczyć plansza

3. Następnie w programie stworzone zostają przestrzenie które są wykorzystane do zrobienia ostatniej przestrzeni w której poprzez którą wykonywany jest cały program.

4. Najpierw zadeklarowana zostaje przestrzeń do podania wielkości planszy. Plansza jest po prostu macierzą, więc program prosi użytkownika o podanie dwóch liczb oddzielonych spacją które będą stanowiły liczbę kolumn i wierszy w 
macierzy. Zostaje rówjnież utworzona macierz pomocnicza o tych samych parametrach.

void Podanie_Wielkosci_Macierzy()
{
	
	cout << "Podaj wielkosc planszy (x y): " << endl;
	        
    cin >> Rozmiar_x >> Rozmiar_y;
    
    cout << "#--------------#" << endl;
    
    int macierz[Rozmiar_x][Rozmiar_y]; // deklaracja wielkosci macierzy na ktorej sie operuje
    
    int macierzpomocnicza[Rozmiar_x][Rozmiar_y]; // deklaracja wielkosci macierzy pomocniczej
    
}

5. Następnie zadeklarowana zostaje przestrzeń majaca na celu wypełnie macierzy planszy, oraz macierzy pomocniczej zerami. Odbywa się to poprzez branie po kolei wszystkich kolumn w danym wierszu.

void Wypelnianie_Macierzy()
{
	x = 0;
		
	while (x < Rozmiar_x)
	{
		y = 0;
		
        while (y < Rozmiar_y) 
		{
            macierz[x][y] = 0;
            
            macierzpomocnicza[x][y] = 0;
            
            y++;
        }
        
        x++;
    }
	
}

6. Następnie zadeklarowana zostaje przestrzeń która słóży do wypisywania aktualnego stanu planszy. Najpierw wyświetlony zostaje numer pokolenia, następnie zostają wypisane kolumny kolejnych wirszy. Dla upiększenia tablicy zostaje
ona wyświetlona wewnątrz ścianek o długości wypisanej planszy.

void Wypisanie_Macierzy()
{
	cout << "#-----------------#" << endl;
	
	cout << "Pokolenie numer: " << numer_generacji << endl;
	
	cout << "#";
	
	x = 0;
	
	while (x < Rozmiar_x*2-1)
	{
		cout << "-";
		
		x++;
	}
	
	cout << "#" << endl;
	
	x = 0;
	
	while (x < Rozmiar_x) 
	{
		y = 0;
		
		cout << " ";
		
        while (y < Rozmiar_y) 
		{
            cout << macierz[x][y] << " ";
            
            y++;
        }
        
        cout << endl;
        
        x++;
    }
    
    cout << "#";
	
	x = 0;
	
	while (x < Rozmiar_x*2-1)
	{
		cout << "-";
		
		x++;
	}
	
	cout << "#" << endl;
}

7. Następnie zadeklarowana zostaje przestrzeń która słóży do oblcizania ilości sąsiednich komurek żywych. Działa to tak że po kolei brana zostaje każda komurka planszy i zliczona jest liczba żywych komórek które leżą w kolumnach i
wierszach obok. Jeżeli jest ich mniej niż dwa, lub więcej niż trzy to dana komórka zmienia się na martwą, jak jest równa 2 lub 3 to zmienia się na żywą. Najpierw wyniki zostają naniesione na macierz pomocniczą. Na koniec wyliczeń
Na plasze naniesione zostają wyniki z macierzy pomocniczej.

void Nowa_Generacja()
{
	
	x = 0;
	
	while (x < Rozmiar_x)
	{
		y = 0;
		
        while (y < Rozmiar_y) 
		{
			komurki_sasiadujace = 0;
			
            if (macierz[x-1][y-1] == 1)
            {
            	komurki_sasiadujace++;
			}
			
			if (macierz[x-1][y] == 1)
            {
            	komurki_sasiadujace++;
			}
			
			if (macierz[x][y-1] == 1)
            {
            	komurki_sasiadujace++;
			}
			
			if (macierz[x-1][y+1] == 1)
            {
            	komurki_sasiadujace++;
			}
			
			if (macierz[x+1][y-1] == 1)
            {
            	komurki_sasiadujace++;
			}
			
			if (macierz[x+1][y+1] == 1)
            {
            	komurki_sasiadujace++;
			}
			
			if (macierz[x][y+1] == 1)
            {
            	komurki_sasiadujace++;
			}
			
			if (macierz[x+1][y] == 1)
            {
            	komurki_sasiadujace++;
			}
			
			if (komurki_sasiadujace < 2 || komurki_sasiadujace > 3)
            {
            	macierzpomocnicza[x][y] = 0;
			}
			
			if (komurki_sasiadujace == 2 || komurki_sasiadujace == 3)
			{
				macierzpomocnicza[x][y] = 1;
			}
			
            y++;
        }
        
        x++;
    }
    
    x = 0;
		
	while (x < Rozmiar_x)
	{
		y = 0;
		
        while (y < Rozmiar_y) 
		{
            macierz[x][y] = macierzpomocnicza[x][y]; 
            
            y++;
        }
        
        x++;
    }
	
}

8. Na koniec zostaje zadeklarowana główna przestrzeń stanowiąca cały interfejs programu. Jest on stworzony w pętli "do while" która na sam koniec sprawdza czy zmienna "opcja" jest równa 1, póki jest to pętla się powtarza.
Użytkownik poprzez podaje "opcja" i w zależnoiści od jej numeru atywuje się inne działąnie, działania działają poprzez katywację wcześniej deklarowanych przestrzeni. Dla 0 jest to wyświetlenie aktualnego stanu planszy. 
Dla 1 dana jest możliwość zmiany stanu komurek. Dla 2 plansza wypisana jest ostatni raz i program wydchodzi z pętli. Dla 3 wyliczona zostaje następna generacja. Dla 4 dana jest możliwość skoku o podaną ilość pokoleń. W przypadku
podania innej opji wyskakuje informacja o błędzie.


void Dzialanie()
{
	
	Wypelnianie_Macierzy();
	
    do {
        cout << "podaj opcje (4 - przeskoczenie, 3 - nastepne pokolenie, 2 - zakoncz, 1 - wpisywanie, 0 - wyswietl)" << endl;
        
        cin >> opcja;
        
        cout << endl;

        if (opcja == 1)
        {
            cout << "Podaj pozycje (x y): ";
            
            cin >> x >> y;
            
            cout << endl;

            if (x >= Rozmiar_x || x < 0 || y >= Rozmiar_y || y < 0)
            {
                cout << "Niepoprawne dane pozycji" << endl;
            }
            
            else // jerzeli wybrana liczba jest rowna 0 to zamieni sie na 1, a jak jest rowna 1 to zamieni sie na 0
            {
            	if (macierz[x][y] == 0)
            	{
            		macierz[x][y] = 1;
				}
				
                else
                {
                	macierz[x][y] = 0;
				}
            }
        }
        
        else if (opcja == 0) // przy opcji 0 konsola wypisuje macierz
        {
            
            Wypisanie_Macierzy();
            
            opcja = 1;
        }
        
        else if (opcja == 2) // przy woborze 2 program wychodzi z petli i sie konczy
        {
        	
        	Wypisanie_Macierzy();
        	
        	cout << "Program zakonczony." << endl << endl;
		}
		
		else if (opcja == 3)
		{
			Nowa_Generacja();
			
			Wypisanie_Macierzy();
			
			opcja = 1;
			
			numer_generacji++;
		}
		
		else if (opcja == 4)
		{
			cout << "Podaj o ile generacji chcesz przeskoczyc: ";
			
			cin >> przeskok;
			
			cout << endl;
			
			do
			{
				
				Nowa_Generacja();
				
				numer_generacji++;
				
				przeskok--;
				
			}while (przeskok != 0);
			
			opcja = 1;
    	}
        
        else
        {
            cout << "Niepoprawna opcja" << endl;
            
            opcja = 1;
        }

    } while (opcja == 1);
}

9. Na sam koniec w przestrzeni programu głównego numer generacji zostaje ustawiony na 0 oraz aktywowane zostają poprzednio zadeklarowane przestrzenie.

int main() 
{
	numer_generacji = 0;
        
	Podanie_Wielkosci_Macierzy();
		
	Dzialanie();

    return 0;
}
